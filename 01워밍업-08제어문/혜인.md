# 01장 프로그래밍

_내용 어쩌구 저쩌구.._

# 04장 변수

## 변수

- 하나의 값을 저장하기 위해 확보한 메모리 공간 혹은 식별을 위해 붙인 이름
- let variable = 123 ⇒ `키워드 변수명 = 값` 의 형태
  - 변수명은 메모리상의 주소를, 값은 주소에 해당하는 값을 의미함
  - 메모리상 값은 언제든 변경이 가능

![image](https://github.com/user-attachments/assets/ef127326-7860-462a-a6ff-9c6eba843902)

- 변수 호이스팅: 변수 선언문이 코드의 가장 처음에 위치한 것처럼 동작하는 JS 고유의 특징
  - 즉, 자바스크립트 엔진은 변수 선언이 어디에 위치하든 다른 코드보다 먼저 실행함
  - 변수 선언은 런타임 이전에 먼저 실행되나 값의 할당은 런타임에 실행됨

## 상수

- 상수는 변하지 않는 값을 의미. 즉, 값을 재할당할 수 없음

## undefined: 값이 정의되지 않은 상태

- undefined는 원시 타입의 값

## null: 해당 변수가 비어있음을 사용자가 의도적으로 나타낼 때 사용

## 메모리

- **`할당 → 사용 → 해제`**의 순서를 거침
- JS는 garbage collector를 통해 사용하지 않는 메모리를 정리함
- JS 엔진은 가상머신으로 구성되어 있음
  - `Heap`: 참조 타입이 들어가며, 메로리 크기가 동적으로 변함
  - `Call Stack`: 원시 타입이 들어감

![image](https://github.com/user-attachments/assets/5ff3407f-6873-415a-a3a4-a0e71d7da696)

    - arr.push(3)과 같은 경우 Heap 메모리 변경

- 메모리가 지워지는 것은 참조가 중요함! (클로저가 가능한 이유도 참조 덕분이라고 할 수 있음)

## 원시 타입과 객체 타입

- 변수를 위해선 임시적인 저장 공간인 메모리 구조를 알아야함
- 원시 타입은 단일 메모리에 할당 되지만, 객체 타입은 메모리 주소가 할당됨
  - 변수는 변수가 지정된 주소를 참조하는 것
- 원시 타입(primitive type): 변경 불가능한 값으로, 원시 값을 변수에 할당하면 메모리 공간에는 실제 값이 저장됨
  - 원시 타입은 값이 변경시 항상 새로운 메모리에 할당됨
  - 읽기 전용의 값
  - 재할당 이외에 변수 값을 변경할 수 있는 방법은 없음
  - cf) 객체를 변수에 할당하면 메모리에는 참조값이 저장됨
- 객체는 변경 가능한 값으로, 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음

### 🧐 예시문제

> 학습한 내용을 제대로 이해했는지 확인을 위해 직접 예시를 만듭니다!
> 혹은 예시들을 어레인지하여 학습의 이해와 효율을 높이는 취지입니다

> const example = true + false + false; 의 결과값은?

### 📑 용어 정리(선택사항)

> 해당 정리에서는 본인만의 기준으로 전반적인 내용을 압축하여 정리합니다! <br/>
> 챕터별 용어의 한 줄 정리, 혹은 관련 내용중 의미깊게 본 내용에 대해 본인만의 최종정리를 통해 마무리합니다

- 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체로, 값의 위치를 가리키는 상직적인 표현
- 표현식: 어떤 결과값으로 평가되는 식

### 🏃 더 나아가기(선택사항)

> 관련하여 학습하면 좋을 키워드 정리 혹은 관련하여 학습한 내용을 작성합니다!
> 스터디원들과 함께 학습시 서로 바라보는 다양한 시야를 공유하고 지식을 나누기 위하여 선택사항으로 추가해봤습니다!

변수를 학습하며 `메모리`에 대해 좀 더 고민을 했습니다. 이후 챕터에도 존재해서 더 심도있게 다룰 예정이나 학습하다가 `리액트 관점`에서 헷갈렸던 점을 깨달아 공유합니다!

- 함수또한 변수처럼 메모리 주소를 갖는다
- 이때, 외부에서 선언된 함수가 **useEffect** 내부에 **dependency**로 포함된 경우 재실행이 아닌 재선언이 된다<br/>
  -> 즉, 리렌더링이 아닌 재정의가 되면서 메모리 주소가 바뀐다고 하네요! dependency는 메모리 주소가 바뀌면서 리렌더 된다는 것을 이번에 깨달았습니당 ㅎㅎ
